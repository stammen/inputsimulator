Windows Input Simulator (C# SendInput Wrapper - Simulate Keyboard and Mouse)
============================================================================
The Windows Input Simulator provides a simple .NET (C#) interface to simulate Keyboard or Mouse input using the Win32 SendInput method. All of the Interop is done for you and there's a simple programming model for sending multiple keystrokes.

Windows Forms provides the SendKeys method which can simulate text entry, but not actual key strokes. Windows Input Simulator can be used in WPF, Windows Forms and Console Applications to synthesize or simulate any Keyboard input including Control, Alt, Shift, Tab, Enter, Space, Backspace, the Windows Key, Caps Lock, Num Lock, Scroll Lock, Volume Up/Down and Mute, Web, Mail, Search, Favorites, Function Keys, Back and Forward navigation keys, Programmable keys and any other key defined in the Virtual Key table. It provides a simple API to simulate text entry, key down, key up, key press and complex modified key strokes and chords.

NuGet
------
Install-Package InputSimulator

Examples
==========

Example: Single key press
-------------
```csharp
public void PressTheSpacebar()
{
  InputSimulator.SimulateKeyPress(VirtualKeyCode.SPACE);
}
```

Example: Key-down and Key-up
------------
```csharp
public void ShoutHello()
{
  // Simulate each key stroke
  InputSimulator.SimulateKeyDown(VirtualKeyCode.SHIFT);
  InputSimulator.SimulateKeyPress(VirtualKeyCode.VK_H);
  InputSimulator.SimulateKeyPress(VirtualKeyCode.VK_E);
  InputSimulator.SimulateKeyPress(VirtualKeyCode.VK_L);
  InputSimulator.SimulateKeyPress(VirtualKeyCode.VK_L);
  InputSimulator.SimulateKeyPress(VirtualKeyCode.VK_O);
  InputSimulator.SimulateKeyPress(VirtualKeyCode.VK_1);
  InputSimulator.SimulateKeyUp(VirtualKeyCode.SHIFT);

  // Alternatively you can simulate text entry to acheive the same end result
  InputSimulator.SimulateTextEntry("HELLO!");
}
```

Example: Modified keystrokes such as CTRL-C
--------------
```csharp
public void SimulateSomeModifiedKeystrokes()
{
  // CTRL-C (effectively a copy command in many situations)
  InputSimulator.SimulateModifiedKeyStroke(VirtualKeyCode.CONTROL, VirtualKeyCode.VK_C);

  // You can simulate chords with multiple modifiers
  // For example CTRL-K-C whic is simulated as
  // CTRL-down, K, C, CTRL-up
  InputSimulator.SimulateModifiedKeyStroke(VirtualKeyCode.CONTROL, new [] {VirtualKeyCode.VK_K, VirtualKeyCode.VK_C});

  // You can simulate complex chords with multiple modifiers and key presses
  // For example CTRL-ALT-SHIFT-ESC-K which is simulated as
  // CTRL-down, ALT-down, SHIFT-down, press ESC, press K, SHIFT-up, ALT-up, CTRL-up
  InputSimulator.SimulateModifiedKeyStroke(
    new[] { VirtualKeyCode.CONTROL, VirtualKeyCode.MENU, VirtualKeyCode.SHIFT },
    new[] { VirtualKeyCode.ESCAPE, VirtualKeyCode.VK_K });
}
```

Example: Simulate text entry
--------
```csharp
public void SayHello()
{
  InputSimulator.SimulateTextEntry("Say hello!");
}
```

Example: Determine the state of different types of keys
------------
```csharp
public void GetKeyStatus()
{
  // Determines if the shift key is currently down
  var isShiftKeyDown = InputSimulator.IsKeyDown(VirtualKeyCode.SHIFT);

  // Determines if the caps lock key is currently in effect (toggled on)
  var isCapsLockOn = InputSimulator.IsTogglingKeyInEffect(VirtualKeyCode.CAPITAL);
}
```

Building for UWP and Unity
------------

In order to get SendInput() to work from a UWP app we need to use an external Win32 exe app that we will communicate with from Unity  via an App Service (kind of like a UWP friendly named pipe). This is an acceptable Desktop Bridge pattern. You will need to make the following changes to your app. 


* Make sure you are on the uwp branch 

* Open the WindowsInput.sln and build for Release/x64

* Open your unity project and add the UWP version of the WindowsInput plugin

  * In your assets/plugins folder create a wsa folder
  
  * In your assets/plugins/wsa folder create a x86_64 folder
  
  * Copy the contents of inputsimulator\WindowsInput-UWP\bin\x64\Release to the assets/plugins/wsa folder in Unity

 * Copy the contents of inputsimulator\SendInput-UWP\bin\x64\Release to the assets/plugins/wsa

* In the Unity editor, click on the SendInput-UWP.dll and set SDK to UWP and select Don’t process in the Inspector

* In the Unity editor, click on the WindowsInput.dll and set SDK to UWP and select Don’t process in the Inspector. Also select your Win32 WindowsInput.DLL as the placeholder for the UWP dll.

* Make sure your original Win32 version of the WindowsInput DLL is disabled for WSAPlayer and Any Platform

* Build your UWP project from Unity.

* Open the UWP solution generated by Unity

* Add the inputsimulator\MRAppService\MRAppService.vcxproj to the solution. Add a reference to this project from your main unity UWP app project.

* Add the inputsimulator\SendInputApp\SendInputApp.vcxproj to the solution. Add a build dependency to this project from your main unity UWP app project.

* Unload your main unity UWP app project by right clicking on the project and select Unload Project

* Right click on your main unity UWP app project by right clicking on the project and select Edit Project

* Add the following code to the end of the xml

```xml
  <ItemGroup>
    <_CustomResource Include="$(SolutionDir)$(Platform)\$(Configuration)\SendInputApp\**\*">
      <Link>SendInputApp\%(RecursiveDir)%(FileName)%(Extension)</Link>
      <DeploymentContent>true</DeploymentContent>
    </_CustomResource>
  </ItemGroup>
  <Target Name="_CollectCustomResources" BeforeTargets="AssignTargetPaths">
    <Message Text="Adding resource: %(_CustomResource.Identity) -&gt; %(_CustomResource.Link)" />
    <ItemGroup>
      <None Include="@(_CustomResource)" />
    </ItemGroup>
  </Target>
```
*	Reload the project by right clicking on your project and select Reload Project

*	Open your Package.appxmanifest file by right clicking on the file and select Open With… and then XML (Text) Editor

*	Make the following changes:

Add the rescap namespace
```xml
<Package xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest" xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10" xmlns:uap2="http://schemas.microsoft.com/appx/manifest/uap/windows10/2" xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities" xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10" IgnorableNamespaces="rescap uap uap2 mp">
```

Add the following Extensions to your Application section

```xml
    </uap:VisualElements>
      <Extensions>
        <uap:Extension Category="windows.protocol" Executable="SendInputApp\SendInputApp.exe" EntryPoint="Windows.FullTrustApplication">
          <uap:Protocol Name="sendinput-win32" />
        </uap:Extension>
        <uap:Extension Category="windows.appService" EntryPoint="MRAppService.AppService">
          <uap:AppService Name="com.sendinput.appservice" />
        </uap:Extension>
      </Extensions>
    </Application>
```
Add the runFullTrust capability
```xml
  <Capabilities>
    <Capability Name="internetClient" />
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
```

*	Add the following code to App.h

```c++
#include <vector>

private:
        void OnBackgroundActivated(Platform::Object^ sender, Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs^ args);
        std::vector<MRAppService::AppService^> m_appServices;
```

*	Add the following code to the App::Initialize() method in App.cpp

```c++
#include <ppltasks.h>
using namespace Concurrency;
using namespace Windows::System;


void App::Initialize(CoreApplicationView^ applicationView)
{
    SetupOrientation();
    m_AppCallbacks = ref new AppCallbacks();
    m_AppCallbacks->SetCoreApplicationViewEvents(applicationView);
    applicationView->Activated += ref new TypedEventHandler<CoreApplicationView ^, IActivatedEventArgs^>(this, &App::OnActivated);
    CoreApplication::BackgroundActivated += ref new EventHandler<BackgroundActivatedEventArgs^>(this, &App::OnBackgroundActivated);

    // Launch the Win32 App
    auto uri = ref new Uri("sendinput-win32:"); // The protocol handled by the launched app
    auto options = ref new LauncherOptions();
    concurrency::task<bool> task(Launcher::LaunchUriAsync(uri, options));
}

void App::OnBackgroundActivated(Platform::Object^ sender, Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs^ args)
{
    auto appService = ref new MRAppService::AppService();
    appService->Run(args->TaskInstance);
    m_appServices.push_back(appService);
}

```

You should now be able to build and run your UWP app with SendInput working. This will also continue to work from the editor. This solution should allow you to use your original inputsimulator code from Unity without any changes.

Please note that I have not yet added support for GetKeyState or GetAsyncKeyState. 



History
============
It was originally written for use in the WpfKB (WPF Touch Screen Keyboard) project to simulate real keyboard entry to the active window. After looking for a comprehensive wrapper for the Win32 and User32 input simulation methods and coming up dry I decided to write and open-source this project. I hope it helps someone out there!
